// Edda Labs Compact Contracts v0.0.1
pragma language_version >= 0.17;

/**
* @description: The main logic is running here. Modules are used to split the logic.
*
* @notice: Access control module is used to manage roles and permissions for automations workflows. Operator approvals under the NonFungibleToken module is used to manage permissions granted by the user to external players.
*
* @notice: Best Practices
* - Modules are being created as in React, self-contained and with its own logic (logic-module + Initializable-module + Pausable-module).
* - All the initializing circuits are called within the constructor. Plus some intial settings.
* - You can export circuits and types from one module and import them into another scope (including the top-level contract). However, the docs don’t show—or suggest—direct access to a module’s ledger state from another module. In practice, inter-module ledger state should flow through circuits (though I couldn’t get that working reliably). Given that, we prefer to read/write state only at the top level when a circuits depends on different modules states. 
* - Modules types and utilites pure functions are used between modules.
* - Utils modules only contain pure circuits.
*
* @notice Missing Features and Improvements:
* - Events
* - Contract-to-Contract Communication
*
* @notice: Design patterns
* - Initializable
* - Pausable
* - Concurrency-safe: use of simple, granular and critical ADTs
* - Low fees: optimized circuits & minimal ADTs interactions
* - High performance: use events to build complex queries offchain
*/

import CompactStandardLibrary;

import "./modules/access-control/AccessControl" prefix AccessControl_;

import "./modules/identity/Identity" prefix Identity_;

import "./modules/token-nft/NonFungibleToken" prefix NonFungibleToken_;

import "./modules/bucket-defi/BucketDEFI" prefix BucketDEFI_;

///////////////////////////////////////////////////////////////////////////////
// PUBLIC STATE FROM MODULES
///////////////////////////////////////////////////////////////////////////////

export { AccessControl__operatorRoles, AccessControl__adminRoles, AccessControl__ADMIN_MASTER };

export { Identity__verifiedUsersforBuckets };

export { NonFungibleToken__name,
         NonFungibleToken__symbol,
         NonFungibleToken__certificatesCreatedCounter,
         NonFungibleToken__owners,
         NonFungibleToken__balances,
         NonFungibleToken__tokenApprovals,
         NonFungibleToken__operatorApprovals,
         NonFungibleToken__tokenToCertificate,
         NonFungibleToken__tokenToPrice,
         NonFungibleToken_Certificate,
         NonFungibleToken_Location,
         NonFungibleToken_Impact,
         NonFungibleToken_Source };

export { BucketDEFI__zkBucketCounter, BucketDEFI_CONDITIONS, BucketDEFI_STATUS }

export { ZswapCoinPublicKey, ContractAddress, Either, CoinInfo };

///////////////////////////////////////////////////////////////////////////////
// PUBLIC STATE TOP LEVEL
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// CIRCUITS GENERAL
///////////////////////////////////////////////////////////////////////////////

/**
* @description: Constructor circuit.
*
* @notice: All the initializing circuits are called here from the modules. Plus some intial settings.
*
* @requirements:
* - Calling all initialized circuits from modules.
* @param {Opaque<"string">} name_ - The name of the token.
* @param {Opaque<"string">} symbol_ - The symbol of the token. 
*/
constructor(_name: Opaque<"string">, _symbol: Opaque<"string">) {
  AccessControl_initialize();
  Identity_initialize();
  NonFungibleToken_initialize(_name, _symbol);
  BucketDEFI_initialize();
}

///////////////////////////////////////////////////////////////////////////////
// CIRCUITS ACCESS CONTROL
///////////////////////////////////////////////////////////////////////////////

/**
* @description: Grants `roleId` to `account`
*
* @circuitInfo k=10, rows=1032
*
* @requirements:
* - Wrapper call
* @param {Bytes<32>} roleId - The role identifier.
* @param {Either<ZswapCoinPublicKey, ContractAddress>} account - The account to query.
* @return {[]} - Empty tuple.
*/
export circuit grantRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): [] {
  AccessControl_grantRole(roleId, account);
}

/**
* @description: Revokes `roleId` to `account`
*
* @circuitInfo k=10, rows=854
*
* @requirements:
* - Wrapper call
* @param {Bytes<32>} roleId - The role identifier.
* @param {Either<ZswapCoinPublicKey, ContractAddress>} account - The account to query.
* @return {[]} - Empty tuple.
*/
export circuit revokeRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): [] {
  AccessControl_revokeRole(roleId, account);
}

/**
* @description: Renounces own RoleID
*
* @circuitInfo k=10, rows=431
*
* @requirements:
* - Wrapper call
* @param {Bytes<32>} roleId - The role identifier.
* @return {[]} - Empty tuple.
*/
export circuit renounceRole(roleId: Bytes<32>,): [] {
  AccessControl_renounceRole(roleId);
}

/**
* @description: Sets `adminRole` as `roleId`'s admin role.
*
* @circuitInfo k=10, rows=449
*
* @requirements:
* - Wrapper call
* @param {Bytes<32>} roleId - The role identifier.
* @param {Bytes<32>} adminRole - The admin role identifier.
*/
export circuit setRoleAdmin(roleId: Bytes<32>, adminRole: Bytes<32>): [] {
  AccessControl_setRoleAdmin(roleId, adminRole);
}

/**
* @description: Removes `adminRole` as `roleId`'s admin role.
*
* @circuitInfo k=10, rows=448
*
* @requirements:
* - Wrapper call
* @param {Bytes<32>} roleId - The role identifier.
* @param {Bytes<32>} adminRole - The admin role identifier.
*/
export circuit removeRoleAdmin(roleId: Bytes<32>, adminRole: Bytes<32>): [] {
  AccessControl_removeRoleAdmin(roleId, adminRole);
}

/**
* @description: Reverts if `ownPublicKey()` is missing `roleId`.
*
* @circuitInfo k=10, rows=356
*
* @requirements:
* - Wrapper call
* @param {Bytes<32>} roleId - The role identifier.
* @return {[]} - Empty tuple.
*/
export circuit assertOnlyRole(roleId: Bytes<32>): [] {
  AccessControl_assertOnlyRole(roleId);
}

/**
* @description: Pause Access Control calls.
*
* @circuitInfo k=10, rows=268
*
* @notice: Only Admin master role can pause Access Control calls.
*
* @requirements:
* - Wrapper call
* @return {[]} - Empty tuple.
*/
export circuit pauseAccessControl(): [] {
  AccessControl_pauseAccessControl();
}

/**
* @description: Unpause Access Control calls.
*
* @circuitInfo k=10, rows=260
*
* @notice: Only Admin master role can unpause Access Control calls.
*
* @requirements:
* - Wrapper call
* @return {[]} - Empty tuple.
*/
export circuit unpauseAccessControl(): [] {
  AccessControl_unpauseAccessControl();
}

///////////////////////////////////////////////////////////////////////////////
// CIRCUITS IDENTITY
///////////////////////////////////////////////////////////////////////////////

/**
* @description: This circuit verifies if the user creating the transaction is a member of the verified users set 
*
* @circuitInfo k=xx, rows=xxx
*
* @requirements:
* - Wrapper call
* @param {} 
*/
export circuit assertOwnVerification(): [] {
  Identity_assertOwnVerification();
}

/**
* @description: This circuit verifies if the user passed as parameter is a member of the verified users set
*
* @circuitInfo k=xx, rows=xx
*
* @requirements:
* - Wrapper call
* @param {ZswapCoinPublicKey} user - User public key that is a member of the verified users set.
* @return {Boolean} 
*/
export circuit isUserVerified(user: ZswapCoinPublicKey): Boolean {
  return Identity_isUserVerified(user);
}

/**
* @description: Includes a user in the verified users set
*
* @circuitInfo k=xx, rows=xx
*
* @notice: Only verifier roles can set users
*
* @requirements:
* - The caller must have `verifier Role`.
* - Wrapper call
* @param {ZswapCoinPublicKey} user - Zswap Coin public key of a new user.
* @return {[]} - Empty tuple.
*/
export circuit setUser(user: ZswapCoinPublicKey): [] {
  assertOnlyRole(8 as Field as Bytes<32>);
  Identity_setUser(user);
}

/**
* @description: Removes a user from the verified users set
*
* @circuitInfo k=xx, rows=xx
*
* @notice: Only verifier roles can remove users
*
* @requirements:
* - The caller must have `verifier Role`.
* - Wrapper call
* @param {ZswapCoinPublicKey} user - Zswap Coin public key of a new user.
* @return {[]} - Empty tuple.
*/
export circuit removeUser(user: ZswapCoinPublicKey): [] {
  assertOnlyRole(8 as Field as Bytes<32>);
  Identity_removeUser(user);
}

/**
* @description: Pause Identity calls.
*
* @circuitInfo k=xx, rows=xx
*
* @notice: Only Admin master role can pause Identity calls.
*
* @requirements:
* - The caller must have `Admins master role`.
* - Wrapper call
* @return {[]} - Empty tuple.
*/
export circuit pauseIdentity(): [] {
  assertOnlyRole(default<Bytes<32>>);
  Identity_pauseIdentity();
}

/**
* @description: Unpause Identity calls.
*
* @circuitInfo k=xx, rows=xx
*
* @notice: Only Admin master role can unpause Identity calls.
*
* @requirements:
* - The caller must have `Admins master role`.
* - Wrapper call
* @return {[]} - Empty tuple.
*/
export circuit unpauseIdentity(): [] {
  assertOnlyRole(default<Bytes<32>>);
  Identity_unpauseIdentity();
}

///////////////////////////////////////////////////////////////////////////////
// CIRCUITS TOKEN
///////////////////////////////////////////////////////////////////////////////

/**
  * @description Returns the number of tokens in `owner`'s account.
  *
  * @circuitInfo k=xx, rows=xx
  *
  * @requirements:
  * - Wrapper call
  * @param {Either<ZswapCoinPublicKey, ContractAddress>)} owner - The account to query.
  * @return {Uint<128>} - The number of tokens in `owner`'s account.
  */
export circuit balanceOf(owner: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
  return NonFungibleToken_balanceOf(owner);
}

/**
* @description Returns the owner of the `tokenId` token. If not revert.
*
* @circuitInfo k=xx, rows=xx
*
* @requirements:
* - Wrapper call
* @param {Uint<128>} tokenId - The identifier for a token.
* @return {Either<ZswapCoinPublicKey, ContractAddress>} - The account that owns the token.
*/
export circuit ownerOf(tokenId: Uint<128>): Either<ZswapCoinPublicKey, ContractAddress> {
  return NonFungibleToken_ownerOf(tokenId);
}

/**
* @description Returns the token Certificate for the given `tokenId`. Reverts if the tokenCertificate does not exist.
*
* @circuitInfo k=xx, rows=xx
*
* @requirements:
* - Wrapper call
* @param {Uint<128>} tokenId - The identifier for a token.
* @return {Certificate} - the token metadata
*/
export circuit tokenCertificate(tokenId: Uint<128>): NonFungibleToken_Certificate {
  return NonFungibleToken_tokenCertificate(tokenId);
}

/**
* @description Returns the token Price for the given `tokenId`. Reverts if the tokenPrice does not exist.
*
* @circuitInfo k=xx, rows=xx
*
* @requirements:
* - Wrapper call
* @param {Uint<128>} tokenId - The identifier for a token.
* @return {Uint<64>} - the price of the token
*/
export circuit tokenPrice(tokenId: Uint<128>): Uint<64> {
  return NonFungibleToken_tokenPrice(tokenId);
}

/**
* @description Mints `tokenId` and transfers it to `to`.
*
* @circuitInfo k=xx, rows=xx
*
* @requirements:
* - The caller must have `Minter role`.
* - Wrapper call
* @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The target account of the token transfer
* @param {Uint<128>} tokenId - The token identifier
* @param {Certificate} tokenCertificate - The token metadata
* @return {[]} - Empty tuple.
*/
export circuit mint(to: Either<ZswapCoinPublicKey, ContractAddress>,
                    tokenId: Uint<128>,
                    tokenCertificate: NonFungibleToken_Certificate,
                    price: Uint<64>
                    ): [] {
  assertOnlyRole(2 as Field as Bytes<32>);
  return NonFungibleToken_mint(to, tokenId, tokenCertificate, price);
}

/**
* @description Destroys `tokenId`. The approval is cleared when the token is burned. This circuit does not check if the sender is authorized to operate on the token.
*
* @circuitInfo k=xx, rows=xx
*
* @requirements:
* - The caller must have `Settler role`.
* - Wrapper call
* @param {Uint<128>} tokenId - The token to burn
* @return {[]} - Empty tuple.
*/
export circuit burn(tokenId: Uint<128>): [] {
  assertOnlyRole(6 as Field as Bytes<32>);
  return NonFungibleToken_burn(tokenId);
}

/**
* @description Sets the price for the given `tokenId`.
*
* @circuitInfo k=xx, rows=xx
*
* @notice Normally this is set during minting, but can be changed afterward to adjust market conditions
*
* @requirements:
* - Wrapper call   
* @param {Uint<128>} tokenId - The identifier of the token.
* @param {Uint<64>} price - The price of the token.
* @return {[]} - Empty tuple.
*/
export circuit setTokenPrice(tokenId: Uint<128>, price: Uint<64>): [] {
  NonFungibleToken_setTokenPrice(tokenId, price);
}

/**
* @description: Pause Token calls.
*
* @circuitInfo k=xx, rows=xx
*
* @notice: Only Admin master role can pause Token calls.
*
* @requirements:
* - The caller must have `Admins master role`.
* - Wrapper call
* @return {[]} - Empty tuple.
*/
export circuit pauseToken(): [] {
  assertOnlyRole(default<Bytes<32>>);
  NonFungibleToken_pauseToken();
}

/**
* @description: Unpause Token calls.
*
* @circuitInfo k=xx, rows=xx
*
* @notice: Only Admin master role can unpause Identity calls.
*
* @requirements:
* - The caller must have `Admins master role`.
* - Wrapper call
* @return {[]} - Empty tuple.
*/
export circuit unpauseToken(): [] {
  assertOnlyRole(default<Bytes<32>>);
  NonFungibleToken_unpauseToken();
}

///////////////////////////////////////////////////////////////////////////////
// CIRCUITS BUCKET DEFI
///////////////////////////////////////////////////////////////////////////////

/**
* @description: Create Buckets.
*
* @circuitInfo k=xx, rows=xx
*
* @notice: The creator should be within the whitelist (Identity module).
*
* @requirements:
* - The caller must be part of the whitelist (Identity module).
* - Wrapper call
* @return {Bytes<32>} ownerCommitment - The ownercommitment created that represents the bucket ID.
*/
export circuit createBucket(conditions: BucketDEFI_CONDITIONS, coin: CoinInfo): Bytes<32> {
  assertOwnVerification();
  return BucketDEFI_createBucket(conditions, coin);
}

/**
* @description: Add a certificate to the bucket if it complies with the conditions
*
* @circuitInfo k=xx, rows=xx
*
* @notice: The matcher can add a certificate to the bucket or the owner of the token.
*
* @requirements:
* - Check that the caller is either a matcher or the owner of the token.
* - Check if the bucket exists, if not revert. Get Bucket Conditions.
* - Check if the token exists, if not revert. Get Token Specs and Token Price.
* - Check if the token complies with the bucket conditions.
* - Wrapper call
* @return {[]} empty tuple
*/
export circuit addCertificateToBucket(ownerCommitment: Bytes<32>, tokenId: Uint<128>): [] {
  // Check if the caller is either a matcher or the owner of the token.
  const owner = NonFungibleToken__ownerOf(tokenId);
  const isOwner = (owner.left == ownPublicKey());
  if (!isOwner) assertOnlyRole(4 as Field as Bytes<32>);

  // Check if the bucket exists, if not revert. Get Bucket Conditions.
  assert(BucketDEFI__zkBucketDEFIConditions.member(disclose(ownerCommitment)), "Bucket not found");
  const bucketConditions = BucketDEFI__zkBucketDEFIConditions.lookup(disclose(ownerCommitment));

  // Check if the token exists, if not revert. Get Token Specs and Token Price.
  assert(NonFungibleToken__tokenToCertificate.member(disclose(tokenId)), "Token not found");
  const tokenSpecs = NonFungibleToken__tokenToCertificate.lookup(disclose(tokenId));
  const tokenPrice = NonFungibleToken__tokenToPrice.lookup(disclose(tokenId));

  // Check if the token complies with the bucket conditions.
  assert(bucketConditions.source == tokenSpecs.source, "Source doesn't match");
  assert(bucketConditions.unitPrice * tokenSpecs.generation >= tokenPrice, "Token price doesn't meet unit price");
  assert(bucketConditions.vintageLimit >= tokenSpecs.vintage, "Token vintage doesn't meet vintage limit");
  assert(bucketConditions.impact == tokenSpecs.impact, "Impact doesn't match");
  assert(bucketConditions.location == tokenSpecs.location, "Location doesn't match");
  assert(bucketConditions.status == BucketDEFI_STATUS.OPEN, "Bucket status isn't open");
  assert(bucketConditions.accumulatedPrice + tokenPrice <= bucketConditions.pot, "Accumulated price exceeds pot");
  assert(blockTimeGte(bucketConditions.startDate), "Current time is before start date");
  assert(blockTimeLte(bucketConditions.endDate), "Current time is after end date");

  // Wrapper call
  return BucketDEFI_addCertificateToBucket(ownerCommitment, tokenId);
}

/**
* @description: Settle the bucket
*
* @circuitInfo k=xx, rows=xx
*
* @notice: The settler can settle the bucket or the owner of the bucket.
*
* @requirements:
* - Check that the caller is either a settler or the owner of the bucket.
* - Wrapper call
* @return {[]} empty tuple
*/
export circuit settleBucket(ownerCommitment: Bytes<32>): [] {
  // Check if the caller is either a settler or the owner of the bucket.
  // Read the witness secret nonce to calculate the owner commitment
  const nonce = BucketDEFI_wit_secretNonce();
  const callerAsEither =
                Either<ZswapCoinPublicKey, ContractAddress> { is_left: true,
                                                              left: ownPublicKey(),
                                                              right: ContractAddress { bytes: pad(32, "") } };
  const id = BucketDEFI__computeOwnerId(callerAsEither, disclose(nonce));
  // get the counter of the commitment
  const counter = BucketDEFI__zkBucketToCounter.lookup(disclose(ownerCommitment));
  const ownerCommitmentCalculated = BucketDEFI__computeOwnerCommitment(id, counter);
  const isOwner = (ownerCommitmentCalculated == ownerCommitment);
  if (!isOwner) assertOnlyRole(6 as Field as Bytes<32>);

  // Wrapper call
  return BucketDEFI_settleBucket(ownerCommitment);
}
