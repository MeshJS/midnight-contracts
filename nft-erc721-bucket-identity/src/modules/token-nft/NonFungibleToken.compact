pragma language_version >= 0.17.0;

module NonFungibleToken {
  import CompactStandardLibrary;
  import "./Initializable" prefix Initializable_;
  import "../utils/Utils" prefix Utils_;

  export enum Source {
    Solar,
    Wind,
    Hydro,
    Biomass,
    Geothermal,
    Nuclear
  }

  export enum Impact {
    Minimal,
    Low,
    Medium,
    High,
    Extreme
  }

  export enum Location {
    RJ,
    SP,
    MG,
    RS
  }

  // Struct holding all attributes for a Certificate.
  export struct Certificate {
    id: Opaque<"string">, // Certificate ID from web2 system
    source: Source, // Type of the certificate    
    generation: Uint<64>, // kWh compensated    
    vintage: Uint<64>, // Expiration date
    impact: Impact, // Impact of the certificate    
    location: Location // Location of the certificate
  }

  /// Public state
  export sealed ledger _name: Opaque<"string">;
  export sealed ledger _symbol: Opaque<"string">;

  export ledger _certificateCounter: Counter;

  export ledger _owners: Map<Uint<64>, Either<ZswapCoinPublicKey, ContractAddress>>;

  export ledger _balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;

  export ledger _tokenApprovals: Map<Uint<64>, Either<ZswapCoinPublicKey, ContractAddress>>;

  export ledger _operatorApprovals: Map<Either<ZswapCoinPublicKey, ContractAddress>,
                                        Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>;

  export ledger _tokenToCertificate: Map<Uint<64>, Certificate>;

  export ledger _tokenToPrice: Map<Uint<64>, Uint<64>>;

  export circuit initialize(name_: Opaque<"string">, symbol_: Opaque<"string">): [] {
    Initializable_initialize();
    _name = disclose(name_);
    _symbol = disclose(symbol_);
    _certificateCounter += 1;
  }

  // export circuit balanceOf(owner: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
  //   Initializable_assertInitialized();
  //   if (!_balances.member(disclose(owner))) {
  //     return 0;
  //   }

  //   return _balances.lookup(disclose(owner));
  // }

  // export circuit ownerOf(tokenId: Uint<64>): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   return _requireOwned(tokenId);
  // }

  // export circuit name(): Opaque<"string"> {
  //   Initializable_assertInitialized();
  //   return _name;
  // }

  // export circuit symbol(): Opaque<"string"> {
  //   Initializable_assertInitialized();
  //   return _symbol;
  // }

  // export circuit tokenURI(tokenId: Uint<64>): Certificate {
  //   Initializable_assertInitialized();
  //   _requireOwned(tokenId);

  //   if (!_tokenURIs.member(disclose(tokenId))) {
  //     return Utils_emptyString();
  //   }

  //   return _tokenURIs.lookup(disclose(tokenId));
  // }

  // export circuit _setTokenURI(tokenId: Uint<64>, tokenURI: Opaque<"string">): [] {
  //   Initializable_assertInitialized();
  //   _requireOwned(tokenId);

  //   return _tokenURIs.insert(disclose(tokenId), disclose(tokenURI));
  // }

  // export circuit approve(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<64>): [] {
  //   Initializable_assertInitialized();
  //   const auth = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
  //   _approve(to, tokenId, auth);
  // }

  // export circuit getApproved(tokenId: Uint<64>): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   _requireOwned(tokenId);

  //   return _getApproved(tokenId);
  // }

  // export circuit setApprovalForAll(
  //                  operator: Either<ZswapCoinPublicKey, ContractAddress>, approved: Boolean): [] {
  //   Initializable_assertInitialized();
  //   const owner = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
  //   _setApprovalForAll(owner, operator, approved);
  // }

  // export circuit isApprovedForAll(
  //                  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  operator: Either<ZswapCoinPublicKey, ContractAddress>
  //                  ): Boolean {
  //   Initializable_assertInitialized();
  //   if (_operatorApprovals.member(disclose(owner)) &&
  //       _operatorApprovals.lookup(owner).member(disclose(operator))) {
  //      return _operatorApprovals.lookup(owner).lookup(disclose(operator));
  //   }
  //   else {
  //      return false;
  //   }
  // }

  // export circuit transferFrom(
  //                  from: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<64>
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isContractAddress(to), "NonFungibleToken: Unsafe Transfer");

  //   _unsafeTransferFrom(from, to, tokenId);
  // }

  // export circuit _unsafeTransferFrom(
  //                  from: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<128>
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isKeyOrAddressZero(to), "NonFungibleToken: Invalid Receiver");
  //   // Setting an "auth" arguments enables the `_isAuthorized` check which verifies that the token exists
  //   // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.
  //   const auth = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
  //   const previousOwner = _update(to, tokenId, auth);
  //   assert(previousOwner == from, "NonFungibleToken: Incorrect Owner");
  // }

  // export circuit _ownerOf(tokenId: Uint<64>): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   if (!_owners.member(disclose(tokenId))) {
  //     return burnAddress();
  //   }

  //   return _owners.lookup(disclose(tokenId));
  // }

  // export circuit _getApproved(tokenId: Uint<64>): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   if (!_tokenApprovals.member(disclose(tokenId))) {
  //     return burnAddress();
  //   }
  //   return _tokenApprovals.lookup(disclose(tokenId));
  // }

  // export circuit _isAuthorized(
  //                  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  spender: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<64>
  //                  ): Boolean {
  //   Initializable_assertInitialized();
  //   return (!Utils_isKeyOrAddressZero(disclose(spender)) &&
  //           (disclose(owner) == disclose(spender) ||
  //            isApprovedForAll(owner, spender) ||
  //            _getApproved(tokenId) == disclose(spender)));
  // }

  // export circuit _checkAuthorized(
  //                  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  spender: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<64>
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   if (!_isAuthorized(owner, spender, tokenId)) {
  //     assert(!Utils_isKeyOrAddressZero(owner), "NonFungibleToken: Nonexistent Token");
  //     assert(false, "NonFungibleToken: Insufficient Approval");
  //   }
  // }

  // circuit _update(to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                 tokenId: Uint<64>,
  //                 auth: Either<ZswapCoinPublicKey, ContractAddress>
  //                 ): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   const from = _ownerOf(tokenId);

  //   // Perform (optional) operator check
  //   if (!Utils_isKeyOrAddressZero(disclose(auth))) {
  //     _checkAuthorized(from, auth, tokenId);
  //   }

  //   // Execute the update
  //   if (!Utils_isKeyOrAddressZero(disclose(from))) {
  //     // Clear approval. No need to re-authorize
  //     _approve(burnAddress(), tokenId, burnAddress());
  //     const newBalance = _balances.lookup(disclose(from)) - 1 as Uint<128>;
  //     _balances.insert(disclose(from), disclose(newBalance));
  //   }

  //   if (!Utils_isKeyOrAddressZero(disclose(to))) {
  //     if (!_balances.member(disclose(to))) {
  //       _balances.insert(disclose(to), 0);
  //     }
  //     const newBalance = _balances.lookup(disclose(to)) + 1 as Uint<128>;
  //     _balances.insert(disclose(to), disclose(newBalance));
  //   }

  //   _owners.insert(disclose(tokenId), disclose(to));

  //   return from;
  // }

  // export circuit _mint(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<64>): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isContractAddress(to), "NonFungibleToken: Unsafe Transfer");

  //   _unsafeMint(to, tokenId);
  // }

  // export circuit _unsafeMint(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<64>): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isKeyOrAddressZero(to), "NonFungibleToken: Invalid Receiver");

  //   const previousOwner = _update(to, tokenId, burnAddress());

  //   assert(Utils_isKeyOrAddressZero(previousOwner), "NonFungibleToken: Invalid Sender");
  // }

  // export circuit _burn(tokenId: Uint<64>): [] {
  //   Initializable_assertInitialized();
  //   const previousOwner = _update(burnAddress(), tokenId, burnAddress());
  //   assert(!Utils_isKeyOrAddressZero(previousOwner), "NonFungibleToken: Invalid Sender");
  // }

  // export circuit _transfer(
  //                  from: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<64>
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isContractAddress(to), "NonFungibleToken: Unsafe Transfer");

  //   _unsafeTransfer(from, to, tokenId);
  // }

  // export circuit _unsafeTransfer(
  //                  from: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<64>
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isKeyOrAddressZero(to), "NonFungibleToken: Invalid Receiver");

  //   const previousOwner = _update(to, tokenId, burnAddress());

  //   assert(!Utils_isKeyOrAddressZero(previousOwner), "NonFungibleToken: Nonexistent Token");
  //   assert(previousOwner == from, "NonFungibleToken: Incorrect Owner");
  // }

  // export circuit _approve(to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                         tokenId: Uint<64>,
  //                         auth: Either<ZswapCoinPublicKey, ContractAddress>
  //                         ): [] {
  //   Initializable_assertInitialized();
  //   if (!Utils_isKeyOrAddressZero(disclose(auth))) {
  //     const owner = _requireOwned(tokenId);

  //     // We do not use _isAuthorized because single-token approvals should not be able to call approve
  //     assert((owner == disclose(auth) || isApprovedForAll(owner, auth)), "NonFungibleToken: Invalid Approver");
  //   }

  //   _tokenApprovals.insert(disclose(tokenId), disclose(to));
  // }

  // export circuit _setApprovalForAll(
  //                  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  operator: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  approved: Boolean
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isKeyOrAddressZero(operator), "NonFungibleToken: Invalid Operator");

  //   if (!_operatorApprovals.member(disclose(owner))) {
  //     _operatorApprovals.insert(
  //       disclose(owner), default<Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>);
  //   }

  //   _operatorApprovals.lookup(owner).insert(disclose(operator), disclose(approved));
  // }

  // export circuit _requireOwned(tokenId: Uint<64>): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   const owner = _ownerOf(tokenId);

  //   assert(!Utils_isKeyOrAddressZero(owner), "NonFungibleToken: Nonexistent Token");
  //   return owner;
  // }
}
