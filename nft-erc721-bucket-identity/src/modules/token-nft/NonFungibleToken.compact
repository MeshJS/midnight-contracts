// Edda Labs Compact Contracts v0.0.1
pragma language_version >= 0.17.0;

/**
* @module: NonFungibleToken
*
* @description: An unshielded Non-Fungible Token library with custom properties stored on-chain.
*
* @notice: Uint<64> is used as the token size because Ledger ADT Counter is being used to get the Token ID. This is due to the Counter maximum size being 64 bits.
*
* @notice: Uint<128> is used as the token balance because Uint<256>
* cannot be supported. This is due to encoding limits on the midnight circuit backend:
* https://github.com/midnightntwrk/compactc/issues/929
*
* @notice Missing Features and Improvements:
* - Events
* - Contract-to-Contract Communication
*
* @notice: Design patterns
* - Initializable
* - Pausable
* - Concurrency-safe: use of simple, granular and critical ADTs
* - Low fees: optimized circuits & minimal ADTs interactions
* - High performance: use events to build complex queries offchain
*/

module NonFungibleToken {
  import CompactStandardLibrary;
  import "./Initializable" prefix Initializable_;
  import "../utils/Utils" prefix Utils_;

  ///////////////////////////////////////////////////////////////////////////////
  // ENUMS
  ///////////////////////////////////////////////////////////////////////////////

  export enum Source {
    Solar,
    Wind,
    Hydro,
    Biomass,
    Geothermal,
    Nuclear
  }

  export enum Impact {
    Minimal,
    Low,
    Medium,
    High,
    Extreme
  }

  export enum Location {
    RJ,
    SP,
    MG,
    RS
  }

  ///////////////////////////////////////////////////////////////////////////////
  // STRUCTS
  ///////////////////////////////////////////////////////////////////////////////

  // Struct holding all attributes for a Certificate.
  export struct Certificate {
    id: Opaque<"string">, // Certificate ID from web2 system
    source: Source, // Type of the certificate    
    generation: Uint<64>, // kWh compensated    
    vintage: Uint<64>, // Expiration date
    impact: Impact, // Impact of the certificate    
    location: Location // Location of the certificate
  }

  ///////////////////////////////////////////////////////////////////////////////
  // PUBLIC STATE
  ///////////////////////////////////////////////////////////////////////////////

  export sealed ledger _name: Opaque<"string">;
  export sealed ledger _symbol: Opaque<"string">;

  /**
    * @description: New counter values will be assigned to new token IDs. 
    *
    * @notice: none 
    *
    * @type: {Counter} 
    */
  export ledger _certificateCounter: Counter;

  /**
  * @description: Mapping from token IDs to their owner addresses(accounts).
  *
  * @notice: Owner addresses can be Zswap Coin public keys or contract addresses. 
  *
  * @type {Uint<64>} tokenId - The unique identifier for a token.
  * @type {Either<ZswapCoinPublicKey, ContractAddress>} owner - The owner address (public key or contract).
  * @type {Map<tokenId, owner>}
  */
  export ledger _owners: Map<Uint<64>, Either<ZswapCoinPublicKey, ContractAddress>>;

  /**
   * @description: Mapping from account addresses to their token balances.
   *
   * @notice: Owner addresses can be Zswap Coin public keys or contract addresses. 
   *
   * @type {Either<ZswapCoinPublicKey, ContractAddress>} owner - The owner address.
   * @type {Uint<128>} balance - The balance of the owner.
   * @type {Map<owner, balance>}
   */
  export ledger _balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;

  /**
  * @description: Mapping from token IDs to approved addresses.
  *
  * @notice: Owner addresses can be Zswap Coin public keys or contract addresses. 
  *
  * @type {Uint<64>} tokenId - The unique identifier for a token.
  * @type {Either<ZswapCoinPublicKey, ContractAddress>} approved - The approved address (public key or contract).
  * @type {Map<tokenId, approved>}
  */
  export ledger _tokenApprovals: Map<Uint<64>, Either<ZswapCoinPublicKey, ContractAddress>>;

  /**
  * @description: Mapping from owner addresses to operator approvals.
  *
  * @notice: Owner addresses can be Zswap Coin public keys or contract addresses. 
  *
  * @type {Either<ZswapCoinPublicKey, ContractAddress>} owner - The owner address.
  * @type {Either<ZswapCoinPublicKey, ContractAddress>} operator - The operator address.
  * @type {Boolean} approved - Whether the operator is approved.
  * @type {Map<owner, Map<operator, approved>>}
  */
  export ledger _operatorApprovals: Map<Either<ZswapCoinPublicKey, ContractAddress>,
                                        Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>;

  /**
  * @description: Mapping from token IDs to their metadata.
  *
  * @notice: none 
  *
  * @type {Uint<64>} tokenId - The unique identifier for a token.
  * @type {Certificate} metadata - Declared as a struct
  * @type {Map<tokenId, metadata>}
  */
  export ledger _tokenToCertificate: Map<Uint<64>, Certificate>;

  /**
   * @description: Mapping from token IDs to their price.
   *
   * @notice: none 
   *
   * @type {Uint<64>} tokenId - The unique identifier for a token.
   * @type {Uint<64>} price - The price of the token. Uint<64> is being used so after summation with other values, it respects max Uint<128>
   * @type {Map<tokenId, price>}
   */
  export ledger _tokenToPrice: Map<Uint<64>, Uint<64>>;

  ///////////////////////////////////////////////////////////////////////////////
  // CIRCUITS
  ///////////////////////////////////////////////////////////////////////////////

  /**
   * @description: Initializes the contract by setting the name and symbol.
   *
   * @notice: This MUST be called in the implementing contract's constructor. Failure to do so can lead to an irreparable contract.
   *
   * @requirements:
   * - Contract is initialized.
   * - Counter is initialized to value = 1  (first token ID)
   * @param {Opaque<"string">} name_ - The name of the token.
   * @param {Opaque<"string">} symbol_ - The symbol of the token. 
   * @return {[]} - Empty tuple.
   */
  export circuit initialize(name_: Opaque<"string">, symbol_: Opaque<"string">): [] {
    Initializable_initialize();
    _name = disclose(name_);
    _symbol = disclose(symbol_);
    _certificateCounter += 1;
  }

  // export circuit balanceOf(owner: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
  //   Initializable_assertInitialized();
  //   if (!_balances.member(disclose(owner))) {
  //     return 0;
  //   }

  //   return _balances.lookup(disclose(owner));
  // }

  // export circuit ownerOf(tokenId: Uint<64>): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   return _requireOwned(tokenId);
  // }

  // export circuit name(): Opaque<"string"> {
  //   Initializable_assertInitialized();
  //   return _name;
  // }

  // export circuit symbol(): Opaque<"string"> {
  //   Initializable_assertInitialized();
  //   return _symbol;
  // }

  // export circuit tokenURI(tokenId: Uint<64>): Certificate {
  //   Initializable_assertInitialized();
  //   _requireOwned(tokenId);

  //   if (!_tokenURIs.member(disclose(tokenId))) {
  //     return Utils_emptyString();
  //   }

  //   return _tokenURIs.lookup(disclose(tokenId));
  // }

  // export circuit _setTokenURI(tokenId: Uint<64>, tokenURI: Opaque<"string">): [] {
  //   Initializable_assertInitialized();
  //   _requireOwned(tokenId);

  //   return _tokenURIs.insert(disclose(tokenId), disclose(tokenURI));
  // }

  // export circuit approve(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<64>): [] {
  //   Initializable_assertInitialized();
  //   const auth = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
  //   _approve(to, tokenId, auth);
  // }

  // export circuit getApproved(tokenId: Uint<64>): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   _requireOwned(tokenId);

  //   return _getApproved(tokenId);
  // }

  // export circuit setApprovalForAll(
  //                  operator: Either<ZswapCoinPublicKey, ContractAddress>, approved: Boolean): [] {
  //   Initializable_assertInitialized();
  //   const owner = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
  //   _setApprovalForAll(owner, operator, approved);
  // }

  // export circuit isApprovedForAll(
  //                  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  operator: Either<ZswapCoinPublicKey, ContractAddress>
  //                  ): Boolean {
  //   Initializable_assertInitialized();
  //   if (_operatorApprovals.member(disclose(owner)) &&
  //       _operatorApprovals.lookup(owner).member(disclose(operator))) {
  //      return _operatorApprovals.lookup(owner).lookup(disclose(operator));
  //   }
  //   else {
  //      return false;
  //   }
  // }

  // export circuit transferFrom(
  //                  from: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<64>
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isContractAddress(to), "NonFungibleToken: Unsafe Transfer");

  //   _unsafeTransferFrom(from, to, tokenId);
  // }

  // export circuit _unsafeTransferFrom(
  //                  from: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<128>
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isKeyOrAddressZero(to), "NonFungibleToken: Invalid Receiver");
  //   // Setting an "auth" arguments enables the `_isAuthorized` check which verifies that the token exists
  //   // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.
  //   const auth = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
  //   const previousOwner = _update(to, tokenId, auth);
  //   assert(previousOwner == from, "NonFungibleToken: Incorrect Owner");
  // }

  // export circuit _ownerOf(tokenId: Uint<64>): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   if (!_owners.member(disclose(tokenId))) {
  //     return burnAddress();
  //   }

  //   return _owners.lookup(disclose(tokenId));
  // }

  // export circuit _getApproved(tokenId: Uint<64>): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   if (!_tokenApprovals.member(disclose(tokenId))) {
  //     return burnAddress();
  //   }
  //   return _tokenApprovals.lookup(disclose(tokenId));
  // }

  // export circuit _isAuthorized(
  //                  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  spender: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<64>
  //                  ): Boolean {
  //   Initializable_assertInitialized();
  //   return (!Utils_isKeyOrAddressZero(disclose(spender)) &&
  //           (disclose(owner) == disclose(spender) ||
  //            isApprovedForAll(owner, spender) ||
  //            _getApproved(tokenId) == disclose(spender)));
  // }

  // export circuit _checkAuthorized(
  //                  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  spender: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<64>
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   if (!_isAuthorized(owner, spender, tokenId)) {
  //     assert(!Utils_isKeyOrAddressZero(owner), "NonFungibleToken: Nonexistent Token");
  //     assert(false, "NonFungibleToken: Insufficient Approval");
  //   }
  // }

  // circuit _update(to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                 tokenId: Uint<64>,
  //                 auth: Either<ZswapCoinPublicKey, ContractAddress>
  //                 ): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   const from = _ownerOf(tokenId);

  //   // Perform (optional) operator check
  //   if (!Utils_isKeyOrAddressZero(disclose(auth))) {
  //     _checkAuthorized(from, auth, tokenId);
  //   }

  //   // Execute the update
  //   if (!Utils_isKeyOrAddressZero(disclose(from))) {
  //     // Clear approval. No need to re-authorize
  //     _approve(burnAddress(), tokenId, burnAddress());
  //     const newBalance = _balances.lookup(disclose(from)) - 1 as Uint<128>;
  //     _balances.insert(disclose(from), disclose(newBalance));
  //   }

  //   if (!Utils_isKeyOrAddressZero(disclose(to))) {
  //     if (!_balances.member(disclose(to))) {
  //       _balances.insert(disclose(to), 0);
  //     }
  //     const newBalance = _balances.lookup(disclose(to)) + 1 as Uint<128>;
  //     _balances.insert(disclose(to), disclose(newBalance));
  //   }

  //   _owners.insert(disclose(tokenId), disclose(to));

  //   return from;
  // }

  // export circuit _mint(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<64>): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isContractAddress(to), "NonFungibleToken: Unsafe Transfer");

  //   _unsafeMint(to, tokenId);
  // }

  // export circuit _unsafeMint(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<64>): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isKeyOrAddressZero(to), "NonFungibleToken: Invalid Receiver");

  //   const previousOwner = _update(to, tokenId, burnAddress());

  //   assert(Utils_isKeyOrAddressZero(previousOwner), "NonFungibleToken: Invalid Sender");
  // }

  // export circuit _burn(tokenId: Uint<64>): [] {
  //   Initializable_assertInitialized();
  //   const previousOwner = _update(burnAddress(), tokenId, burnAddress());
  //   assert(!Utils_isKeyOrAddressZero(previousOwner), "NonFungibleToken: Invalid Sender");
  // }

  // export circuit _transfer(
  //                  from: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<64>
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isContractAddress(to), "NonFungibleToken: Unsafe Transfer");

  //   _unsafeTransfer(from, to, tokenId);
  // }

  // export circuit _unsafeTransfer(
  //                  from: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  tokenId: Uint<64>
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isKeyOrAddressZero(to), "NonFungibleToken: Invalid Receiver");

  //   const previousOwner = _update(to, tokenId, burnAddress());

  //   assert(!Utils_isKeyOrAddressZero(previousOwner), "NonFungibleToken: Nonexistent Token");
  //   assert(previousOwner == from, "NonFungibleToken: Incorrect Owner");
  // }

  // export circuit _approve(to: Either<ZswapCoinPublicKey, ContractAddress>,
  //                         tokenId: Uint<64>,
  //                         auth: Either<ZswapCoinPublicKey, ContractAddress>
  //                         ): [] {
  //   Initializable_assertInitialized();
  //   if (!Utils_isKeyOrAddressZero(disclose(auth))) {
  //     const owner = _requireOwned(tokenId);

  //     // We do not use _isAuthorized because single-token approvals should not be able to call approve
  //     assert((owner == disclose(auth) || isApprovedForAll(owner, auth)), "NonFungibleToken: Invalid Approver");
  //   }

  //   _tokenApprovals.insert(disclose(tokenId), disclose(to));
  // }

  // export circuit _setApprovalForAll(
  //                  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  operator: Either<ZswapCoinPublicKey, ContractAddress>,
  //                  approved: Boolean
  //                  ): [] {
  //   Initializable_assertInitialized();
  //   assert(!Utils_isKeyOrAddressZero(operator), "NonFungibleToken: Invalid Operator");

  //   if (!_operatorApprovals.member(disclose(owner))) {
  //     _operatorApprovals.insert(
  //       disclose(owner), default<Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>);
  //   }

  //   _operatorApprovals.lookup(owner).insert(disclose(operator), disclose(approved));
  // }

  // export circuit _requireOwned(tokenId: Uint<64>): Either<ZswapCoinPublicKey, ContractAddress> {
  //   Initializable_assertInitialized();
  //   const owner = _ownerOf(tokenId);

  //   assert(!Utils_isKeyOrAddressZero(owner), "NonFungibleToken: Nonexistent Token");
  //   return owner;
  // }
}
