// Edda Labs Compact Contracts v0.0.1
pragma language_version >= 0.17.0;

/**
* @module: BucketDEFI
*
* @description: BucketDEFI is a module for creating and managing DEFI “buckets” that group NFT certificates under shared conditions, identity of the certificate is the public key of the owner and identity of the bucket is the public key of the owner + witness nonce + counter, so the bucket identity is not traceable.
*
* @notice: Initialization logic is all handled within the module. All callable circuits (not with prefix _) are protected by `Initializable_assertInitialized()`. 
*
* @notice: Burn of the token will take place when the certificates rewards are claimed. 
*
* @notice Missing Features and Improvements:
* - Events
* - Contract-to-Contract Communication
*
* @notice: Design patterns
* - Initializable
* - Pausable
* - Concurrency-safe: use of simple, granular and critical ADTs
* - Low fees: optimized circuits & minimal ADTs interactions
* - High performance: use events to build complex queries offchain
*/

module BucketDEFI {
  import CompactStandardLibrary;
  import "./Initializable" prefix Initializable_;
  import "./Pausable" prefix Pausable_;
  import "../token-nft/NonFungibleToken" prefix NonFungibleToken_;

  ///////////////////////////////////////////////////////////////////////////////
  // ENUMS
  ///////////////////////////////////////////////////////////////////////////////

  export enum STATUS {
    OPEN,
    SETTLED,
    CLAIMED
  }

  ///////////////////////////////////////////////////////////////////////////////
  // STRUCTS
  ///////////////////////////////////////////////////////////////////////////////

  // Struct holding all conditions for a bucket.
  export struct CONDITIONS {
    source: NonFungibleToken_Source, // Type of the certificate    
    unitPrice: Uint<64>, // unity cost energy/price
    vintageLimit: Uint<64>, // Maximum Expiration date
    impact: NonFungibleToken_Impact, // Impact of the certificate    
    location: NonFungibleToken_Location, // Location of the certificate
    status: STATUS, // Status of the bucket
    accumulatedPrice: Uint<128>, // Accumulated price of the bucket
    pot: Uint<128>, // Pot of the bucket
    startDate: Uint<64>, // Start date of the bucket
    endDate: Uint<64>, // End date of the bucket
  }

  ///////////////////////////////////////////////////////////////////////////////
  // PUBLIC STATE
  ///////////////////////////////////////////////////////////////////////////////

  /**
  * @description: ZK Bucket representation during DEFI  
  *
  * @notice: none
  *
  * @type: {Bytes<32>} ZK Bucket Identity - Hash of owner public key + witness nonce + counter.  
  * @type: {Uint<128>} TokenID - Identification of the certificate
  * @type: {Map<ZK-Bucket-Identity, Map<TokenID, Set<Owner>>>} 
  */
  export ledger _zkBucketDEFI: Map<Bytes<32>, Set<Uint<128>>>;

  /**
  * @description: ZK Bucket Conditions  
  *
  * @notice: none
  *
  * @type: {Bytes<32>} ZK Bucket Identity - Hash of owner public key + witness nonce + counter.  
  * @type: {CONDITIONS} Condition - Struct created
  * @type: {Map<ZK-Bucket-Identity, Condition>} 
  */
  export ledger _zkBucketDEFIConditions: Map<Bytes<32>, CONDITIONS>;

  /**
  * @description: ZK Bucket Pot  
  *
  * @notice: none
  *
  * @type: {Bytes<32>} ZK Bucket Identity - Hash of owner public key + witness nonce + counter.  
  * @type: {QualifiedCoinInfo} Pot - Amount of resources available for this bucket
  * @type: {Map<ZK-Bucket-Identity, POT>} 
  */
  export ledger _zkBucketDEFIPot: Map<Bytes<32>, QualifiedCoinInfo>;

  /**
  * @description: Bucket Commitment tracked with counter
  *
  * @notice: none
  *
  * @type: {Bytes<32>} ZK Bucket Identity - Hash of owner public key + witness nonce + counter.
  * @type: {Uint<64>} Counter - Bucket counter used when calculated the hash
  * @type: {Map<ZK-Bucket-Identity, Counter>} 
  */
  export ledger _zkBucketToCounter: Map<Bytes<32>, Uint<64>>;

  // Counter for calculating the bucket commitment
  export ledger _zkBucketCounter: Counter;

  /**
  * @description: Used to track verifications made by the user using a challenge
  *
  * @notice: none
  *
  * @type: {Bytes<32>} Challenge - Random number generated offchain specifically for a single user.   
  * @type: {Bytes<32>} ZK Bucket Identity - Hash of owner public key + witness nonce + counter. 
  * @type: {Map<Challenge, Set<ZK-Bucket-Identity>>} 
  */
  export ledger _authVerifications: Map<Bytes<32>, Set<Bytes<32>>>;

  /**
   * @description: Track of certificates locked to the bucket
   *
   * @notice: none
   *
   * @type: {Uint<128>} TokenID - Identification of the certificate
   * @type: {Bytes<32>} ZK Bucket Identity - Hash of owner public key + witness nonce + counter.
   * @type: {Map<TokenID, ZK Bucket Identity>} 
   */
  export ledger _certificateToBucket: Map<Uint<128>, Bytes<32>>;

  /**
  * @description: Track of certificates added to a bucket so they can be placed in multiple buckets
  *
  * @notice: none
  *
  * @type: {Uint<128>} TokenID - Identification of the certificate
  * @type: {Boolean} isLocked - The certificate is locked in a bucket 
  * @type: {Map<TokenID, isLocked>} 
  */
  export ledger _certificateLocked: Map<Uint<128>, Boolean>;

  /**
  * @description: Track of certificates claimed
  *
  * @notice: none
  *
  * @type: {Uint<128>} TokenID - Identification of the certificate
  * @type: {Boolean} isSold - The certificate is sold
  * @type: {Map<TokenID, isSold>} 
  */
  export ledger _certificateClaimed: Map<Uint<128>, Boolean>;

  ///////////////////////////////////////////////////////////////////////////////
  // WITNESS
  ///////////////////////////////////////////////////////////////////////////////

  // Secret nonce used for calculating the owner commitment
  export witness wit_secretNonce(): Bytes<32>;

  ///////////////////////////////////////////////////////////////////////////////
  // CIRCUITS
  ///////////////////////////////////////////////////////////////////////////////

  /**
   * @description: Initializes the contract.
   *
   * @notice: This MUST be called in the implementing contract's constructor. Failure to do so can lead to an irreparable contract.
   *
   * @requirements:
   * - Contract is initialized. 
   * @return {[]} - Empty tuple.
   */
  export circuit initialize(): [] {
    Initializable_initialize();
  }

  /**
   * @description: Create a new bucket.
   *
   * @notice: None.
   *
   * @requirements:
   * - Contract is initialized. 
   * - The coin is received from ZSwap and check conditions
   * - Read the witness secret nonce to calculate the owner commitment
   * - Insert the owner commitment with the counter
   * - Insert the owner commitment with the conditions
   * - Insert the owner commitment with the pot
   * - Create the bucket with the new owner commitment
   * - Increment the counter
   * @param {CONDITIONS} conditions - The conditions of the bucket.
   * @param {CoinInfo} coin - The coin the user has to deposit into the contract
   * @return {Bytes<32>} ownerCommitment - The ownercommitment created that represents the bucket ID.
   */
  export circuit createBucket(conditions: CONDITIONS, coin: CoinInfo): Bytes<32> {
    Initializable_assertInitialized();

    // The coin is received from ZSwap and check conditions
    receive(disclose(coin));
    assert(coin.value == conditions.pot, "requires to deposit the pot amount");
    assert(coin.color == nativeToken(), "Invalid coin provided");

    // Read the witness secret nonce to calculate the owner commitment
    const nonce = wit_secretNonce();
    const callerAsEither =
                  Either<ZswapCoinPublicKey, ContractAddress> { is_left: true,
                                                                left: ownPublicKey(),
                                                                right: ContractAddress { bytes: pad(32, "") } };
    const id = _computeOwnerId(callerAsEither, disclose(nonce));
    const ownerCommitment = _computeOwnerCommitment(id, _zkBucketCounter);

    // Insert the owner commitment with the counter
    _zkBucketToCounter.insert(ownerCommitment, _zkBucketCounter);

    // Insert the owner commitment with the conditions
    _zkBucketDEFIConditions.insert(ownerCommitment, disclose(conditions));

    // Insert the owner commitment with the pot
    _zkBucketDEFIPot.insertCoin(
      ownerCommitment, disclose(coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    // Create the bucket with the new owner commitment
    _zkBucketDEFI.insert(ownerCommitment, default<Set<Uint<128>>>);

    // Increment the counter
    _zkBucketCounter += 1;

    // Return the owner commitment
    return ownerCommitment;
  }

  /**
     * @description: Add a certificate to the bucket
     *
     * @notice: Still need to implement the logic to check if the certificate complies with the conditions. Since this involves analizing different module states, this will be done at the top-level contract.
     *
     * @requirements:
     * - Contract is initialized. 
     * - confirmed the certificate is not locked
     * - Insert a certificate into a bucket
     * - Locked the certificate
     * - Track the certificate to the bucket
     * @param {Bytes<32>} ownerCommitment - The ownercommitment created that represents the bucket ID.
     * @param {Uint<128>} tokenId - The token ID of the certificate
     * @return {[]} empty tuple
     */
  export circuit addCertificateToBucket(ownerCommitment: Bytes<32>, tokenId: Uint<128>): [] {
    Initializable_assertInitialized();

    // Confirm the certificate is not locked
    assert(!_isTokenLocked(tokenId), "Token is locked");

    // Insert a certificate into a bucket
    _zkBucketDEFI.lookup(disclose(ownerCommitment)).insert(disclose(tokenId));

    // Lock the certificate
    _certificateLocked.insert(disclose(tokenId), true);

    // Track the certificate to the bucket
    _certificateToBucket.insert(disclose(tokenId), disclose(ownerCommitment));

    return [];
  }

  /**
  * @description: Settle the bucket
  *
  * @notice: Still need to implement the access control logic
  *
  * @requirements:
  * - Contract is initialized. 
  * - get condition of the bucket 
  * - Check if the bucket is already settled
  * - Check if conditions are met
  * - update the condition
  * @param {Bytes<32>} ownerCommitment - The ownercommitment created that represents the bucket ID.
  * @return {[]} empty tuple
  */
  export circuit settleBucket(ownerCommitment: Bytes<32>): [] {
    Initializable_assertInitialized();

    // get condition of the bucket 
    const conditions = _zkBucketDEFIConditions.lookup(disclose(ownerCommitment));

    // Check if the bucket is already settled
    assert(conditions.status != STATUS.SETTLED, "Bucket is already settled");

    // Check if conditions are met
    assert(blockTimeGte(conditions.endDate), "Current time is before end date");

    // Update the condition
    const updatedCond = CONDITIONS { ...conditions, status: STATUS.SETTLED };
    _zkBucketDEFIConditions.insert(disclose(ownerCommitment), updatedCond);

    return [];
  }

  /**
     * @description: Creates the owner commitment based on the ownerID and the counter
     *
     * @notice: None.
     *
     * @requirements:
     * - Hash of id, counter and spacer
     * @param {Bytes<32>} id - OwnerId this is created using _computeOwnerId.
     * @param {Uint<64>} coin - The value of the counter
     * @return {Bytes<32>} ownerCommitment - The ownercommitment created that represents the bucket ID.
     */
  export circuit _computeOwnerCommitment(id: Bytes<32>, counter: Uint<64>): Bytes<32> {
    return persistentHash<Vector<3, Bytes<32>>>(
             [id, counter as Field as Bytes<32>, pad(32, "BucketDEFI: shield:")]);
  }

  /**
     * @description: Creates the owner ID based on the owner account and the nonce
     *
     * @notice: None.
     *
     * @requirements:
     * - Confirm it is a public key
     * - Hash of public key and nonce
     * @param {Either<ZswapCoinPublicKey, ContractAddress>} pk - Owner account
     * @param {Bytes<32>} Nonce - The secret value from the client
     * @return {Bytes<32>} ownerID - This will be used to calculate the owner commitment
     */
  export pure circuit _computeOwnerId(
                        pk: Either<ZswapCoinPublicKey, ContractAddress>, nonce: Bytes<32>): Bytes<32> {
    assert(pk.is_left, "BucketDEFI: contract address owners are not yet supported");
    return persistentHash<Vector<2, Bytes<32>>>([pk.left.bytes, nonce]);
  }

  /**
   * @description: Checks if a token is locked
   *
   * @notice: None.
   *
   * @requirements:
   * - confirm if token is part of the map
   * - confirm if it is locked
   * @param {Uint<128>} tokenId - The certificate number
   * @return {Boolean} result - If the token is looked or not
   */
  export circuit _isTokenLocked(tokenId: Uint<128>): Boolean {
    if (_certificateLocked.member(disclose(tokenId))) {
      return _certificateLocked.lookup(disclose(tokenId));
    }
    return false;
  }
}
