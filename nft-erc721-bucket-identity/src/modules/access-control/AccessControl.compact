// Edda Labs Compact Contracts v0.0.1
pragma language_version >= 0.17.0;

/**
* @module: AccessControl
*
* @description: An unshielded AccessControl library. This module provides a role-based access control mechanism, where roles can be used to represent a set of permissions.
*
* @notice: Roles are referred to by their `Bytes<32>` identifier. Admin Master is the only role that can grant and revoke adminroles {_adminRoles}. The Admin master is the default role. Each role has an associated admin role, and only accounts that have a role's admin role can update {_operatorRoles}.
* 
* @notice: Admin master role is initialized to the contract owner during initialization. One way to achieve/guarantee this is by using `export sealed ledger`
*
* @notice Missing Features and Improvements:
* - Events
* - Contract-to-Contract Communication
*
* @notice: Design patterns
* - Initializable
* - Pausable
* - Concurrency-safe: use of simple, granular and critical ADTs
* - Low fees: optimized circuits & minimal ADTs interactions
* - High performance: use events to build complex queries offchain
*/

module AccessControl {
  import CompactStandardLibrary;
  import "../utils/Utils" prefix Utils_;
  import "./Initializable" prefix Initializable_;

  ///////////////////////////////////////////////////////////////////////////////
  // PUBLIC STATE
  ///////////////////////////////////////////////////////////////////////////////

  /**
  * @description: Mapping from a role identifier -> account -> its permissions.
  *
  * @notice: none 
  *
  * @type {Bytes<32>} roleId - A hash representing a role identifier.
  * @type {Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>} hasRole - A mapping from an account to a Boolean determining if the account is approved for a role.
  * @type {Map<roleId, hasRole>}
  */
  export ledger _operatorRoles: Map<Bytes<32>,
                                    Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>;

  /**
  * @description: Mapping from a role identifier to an admin role identifier.
  *
  * @notice: none 
  *
  * @type {Bytes<32>} roleId - A hash representing a role identifier.
  * @type {Bytes<32>} adminId - A hash representing an admin identifier.
  * @type {Map<roleId, adminId>}
  */
  export ledger _adminRoles: Map<Bytes<32>, Bytes<32>>;

  /**
  * @description: Master Admin role identifier. It has control over the other admin IDs.
  *
  * @notice: none 
  *
  * @type {Bytes<32>} MasterAdminroleId - A hash representing a master admin role identifier.
  */
  export sealed ledger _ADMIN_MASTER: Bytes<32>;

  ///////////////////////////////////////////////////////////////////////////////
  // CIRCUITS
  ///////////////////////////////////////////////////////////////////////////////

  /**
  * @description: Initializes the contract.
  *
  * @notice: This MUST be called in the implementing contract's constructor. Failure to do so can lead to an irreparable contract.
  *
  * @requirements:
  * - Contract is initialized.
  * - Admin master role ID is set to default.
  * - Create and set admin roles for roles: minter, matcher, settler.
  * @param {Opaque<"string">} name_ - The name of the token.
  * @param {Opaque<"string">} symbol_ - The symbol of the token. 
  * @return {[]} - Empty tuple.
  */
  export circuit initialize(): [] {
    Initializable_initialize();
    _ADMIN_MASTER = default<Bytes<32>>;
    _unsafeGrantRole(_ADMIN_MASTER, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
    _adminRoles.insert(pad(32, "minter"), pad(32, "minterAdmin"));
    _adminRoles.insert(pad(32, "matcher"), pad(32, "matcherAdmin"));
    _adminRoles.insert(pad(32, "settler"), pad(32, "settlerAdmin"));
  }

  export circuit hasRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
    if (_operatorRoles.member(disclose(roleId)) &&
        _operatorRoles.lookup(roleId).member(disclose(account))) {
       return _operatorRoles.lookup(roleId).lookup(disclose(account));
    }
    else {
       return false;
    }
  }

  export circuit assertOnlyRole(roleId: Bytes<32>): [] {
    _checkRole(roleId, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
  }

  export circuit _checkRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    assert(hasRole(roleId, account), "AccessControl: unauthorized account");
  }

  export circuit getRoleAdmin(roleId: Bytes<32>): Bytes<32> {
    if (_adminRoles.member(disclose(roleId))) {
      return _adminRoles.lookup(disclose(roleId));
    }
    return default<Bytes<32>>;
  }

  export circuit grantRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    assertOnlyRole(getRoleAdmin(roleId));
    _grantRole(roleId, account);
  }

  export circuit grantRolefromAdminMaster(
                   roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    assertOnlyRole(default<Bytes<32>>);
    _grantRole(roleId, account);
  }

  export circuit revokeRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    assertOnlyRole(getRoleAdmin(roleId));
    _revokeRole(roleId, account);
  }

  export circuit renounceRole(
                   roleId: Bytes<32>,
                   callerConfirmation: Either<ZswapCoinPublicKey, ContractAddress>
                   ): [] {
    assert(callerConfirmation == left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), "AccessControl: bad confirmation");

    _revokeRole(roleId, callerConfirmation);
  }

  export circuit setAdminRoleFromAdminMaster(roleId: Bytes<32>, adminRole: Bytes<32>): [] {
    assertOnlyRole(default<Bytes<32>>);
    _adminRoles.insert(disclose(roleId), disclose(adminRole));
  }

  export circuit _grantRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
    assert(!Utils_isContractAddress(account), "AccessControl: unsafe role approval");
    return _unsafeGrantRole(roleId, account);
  }

  /**
   * @description: Attempts to grant `roleId` to `account` and returns a boolean indicating if `roleId` was granted. Internal circuit without access restriction.
   *
   * @notice: External smart contracts cannot call the token contract at this time, so granting a role to an ContractAddress may render a circuit permanently inaccessible.
   *
   * @requirements:
   * - Check if Contract is initialized.
   * - Check if `account` has `roleId`.
   * - If `account` does not have `roleId`, insert `roleId` into `_operatorRoles` and set `account`'s permission to `true`.
   * @param {Bytes<32>} roleId - The role identifier.
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} account - A ZswapCoinPublicKey or ContractAddress.
   * @return {Boolean} roleGranted - A boolean indicating if `role` was granted.
   */
  export circuit _unsafeGrantRole(
                   roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
    Initializable_assertInitialized();
    if (hasRole(roleId, account)) {
      return false;
    }

    if (!_operatorRoles.member(disclose(roleId))) {
      _operatorRoles.insert(
        disclose(roleId), default<Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>);
      _operatorRoles.lookup(roleId).insert(disclose(account), true);
      return true;
    }

    _operatorRoles.lookup(roleId).insert(disclose(account), true);
    return true;
  }

  export circuit _revokeRole(
                   roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
    if (!hasRole(roleId, account)) {
      return false;
    }

    _operatorRoles.lookup(roleId).insert(disclose(account), false);
    return true;
  }
}
