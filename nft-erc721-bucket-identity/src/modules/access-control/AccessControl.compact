// Edda Labs Compact Contracts v0.0.1
pragma language_version >= 0.17.0;

/**
* @module: AccessControl
*
* @description: An unshielded AccessControl library. This module provides a role-based access control mechanism, where roles can be used to represent a set of permissions.
*
* @notice: Roles are referred to by their `Bytes<32>` identifier. Admin Master is the only role that can grant and revoke adminroles {_adminRoles}. The Admin master is the default role. Each role has an associated admin role, and only accounts that have a role's admin role can update {_operatorRoles}.
* 
* @notice: Admin master role is initialized to the contract owner during initialization. One way to achieve/guarantee this is by using `export sealed ledger`
*
* @notice Missing Features and Improvements:
* - Events
* - Contract-to-Contract Communication
*
* @notice: Design patterns
* - Initializable
* - Pausable
* - Concurrency-safe: use of simple, granular and critical ADTs
* - Low fees: optimized circuits & minimal ADTs interactions
* - High performance: use events to build complex queries offchain
*/

module AccessControl {
  import CompactStandardLibrary;
  import "../utils/Utils" prefix Utils_;
  import "./Initializable" prefix Initializable_;

  ///////////////////////////////////////////////////////////////////////////////
  // PUBLIC STATE
  ///////////////////////////////////////////////////////////////////////////////

  export ledger _operatorRoles: Map<Bytes<32>,
                                    Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>;

  export ledger _adminRoles: Map<Bytes<32>, Bytes<32>>;

  export sealed ledger _ADMIN_MASTER: Bytes<32>;

  export circuit initialize(): [] {
    Initializable_initialize();
    _ADMIN_MASTER = default<Bytes<32>>;
    _unsafeGrantRole(_ADMIN_MASTER, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
  }

  export circuit hasRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
    if (_operatorRoles.member(disclose(roleId)) &&
        _operatorRoles.lookup(roleId).member(disclose(account))) {
       return _operatorRoles.lookup(roleId).lookup(disclose(account));
    }
    else {
       return false;
    }
  }

  export circuit assertOnlyRole(roleId: Bytes<32>): [] {
    _checkRole(roleId, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
  }

  export circuit _checkRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    assert(hasRole(roleId, account), "AccessControl: unauthorized account");
  }

  export circuit getRoleAdmin(roleId: Bytes<32>): Bytes<32> {
    if (_adminRoles.member(disclose(roleId))) {
      return _adminRoles.lookup(disclose(roleId));
    }
    return default<Bytes<32>>;
  }

  export circuit grantRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    assertOnlyRole(getRoleAdmin(roleId));
    _grantRole(roleId, account);
  }

  export circuit grantRolefromAdminMaster(
                   roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    assertOnlyRole(default<Bytes<32>>);
    _grantRole(roleId, account);
  }

  export circuit revokeRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    assertOnlyRole(getRoleAdmin(roleId));
    _revokeRole(roleId, account);
  }

  export circuit renounceRole(
                   roleId: Bytes<32>,
                   callerConfirmation: Either<ZswapCoinPublicKey, ContractAddress>
                   ): [] {
    assert(callerConfirmation == left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), "AccessControl: bad confirmation");

    _revokeRole(roleId, callerConfirmation);
  }

  export circuit setAdminRoleFromAdminMaster(roleId: Bytes<32>, adminRole: Bytes<32>): [] {
    assertOnlyRole(default<Bytes<32>>);
    _adminRoles.insert(disclose(roleId), disclose(adminRole));
  }

  export circuit _grantRole(roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
    assert(!Utils_isContractAddress(account), "AccessControl: unsafe role approval");
    return _unsafeGrantRole(roleId, account);
  }

  export circuit _unsafeGrantRole(
                   roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
    Initializable_assertInitialized();
    if (hasRole(roleId, account)) {
      return false;
    }

    if (!_operatorRoles.member(disclose(roleId))) {
      _operatorRoles.insert(
        disclose(roleId), default<Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>);
      _operatorRoles.lookup(roleId).insert(disclose(account), true);
      return true;
    }

    _operatorRoles.lookup(roleId).insert(disclose(account), true);
    return true;
  }

  export circuit _revokeRole(
                   roleId: Bytes<32>, account: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
    if (!hasRole(roleId, account)) {
      return false;
    }

    _operatorRoles.lookup(roleId).insert(disclose(account), false);
    return true;
  }
}
