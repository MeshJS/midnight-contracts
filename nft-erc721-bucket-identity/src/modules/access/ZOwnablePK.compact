pragma language_version >= 0.17.0;

module ZOwnablePK {
  import CompactStandardLibrary;
  import "../security/Initializable" prefix Initializable_;

  export ledger _ownerCommitment: Bytes<32>;

  export ledger _counter: Counter;

  export sealed ledger _instanceSalt: Bytes<32>;

  export witness wit_secretNonce(): Bytes<32>;

  export circuit initialize(ownerId: Bytes<32>, instanceSalt: Bytes<32>): [] {
    Initializable_initialize();

    assert(ownerId != default<Bytes<32>>, "ZOwnablePK: invalid id");
    _instanceSalt = disclose(instanceSalt);
    _transferOwnership(ownerId);
  }

  export circuit owner(): Bytes<32> {
    Initializable_assertInitialized();
    return _ownerCommitment;
  }

  export circuit transferOwnership(newOwnerId: Bytes<32>): [] {
    Initializable_assertInitialized();

    assertOnlyOwner();
    assert(newOwnerId != default<Bytes<32>>, "ZOwnablePK: invalid id");
    _transferOwnership(newOwnerId);
  }

  export circuit renounceOwnership(): [] {
    Initializable_assertInitialized();

    assertOnlyOwner();
    _ownerCommitment.resetToDefault();
  }

  export circuit assertOnlyOwner(): [] {
    Initializable_assertInitialized();

    const nonce = wit_secretNonce();
    const callerAsEither = Either<ZswapCoinPublicKey, ContractAddress> {
      is_left: true,
      left: ownPublicKey(),
      right: ContractAddress { bytes: pad(32, "") }
    };
    const id = _computeOwnerId(callerAsEither, nonce);
    assert(_ownerCommitment == _computeOwnerCommitment(id, _counter), "ZOwnablePK: caller is not the owner");
  }

  export circuit _computeOwnerCommitment(
    id: Bytes<32>,
    counter: Uint<64>,
  ): Bytes<32> {
    Initializable_assertInitialized();
    return persistentHash<Vector<4, Bytes<32>>>(
      [
        id,
        _instanceSalt,
        counter as Field as Bytes<32>,
        pad(32, "ZOwnablePK:shield:")
      ]
    );
  }
 
  export pure circuit _computeOwnerId(
    pk: Either<ZswapCoinPublicKey, ContractAddress>,
    nonce: Bytes<32>
  ): Bytes<32> {
    assert(pk.is_left, "ZOwnablePK: contract address owners are not yet supported");

    return persistentHash<Vector<2, Bytes<32>>>([pk.left.bytes, nonce]);
  }

  export circuit _transferOwnership(newOwnerId: Bytes<32>): [] {
    Initializable_assertInitialized();

    _counter.increment(1);
    _ownerCommitment = _computeOwnerCommitment(disclose(newOwnerId), _counter);
  }
}
